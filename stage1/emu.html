<html>

<head>
</head>

<body>
    <canvas></canvas>
</body>

<script>
    const bytesPerInstruction = 6;
    const maxProcess = 100;
    const registerNum = 12;
    const processTableEntrySize = 1 + 2 + 2 + registerNum * 2; // sleep=0/active=1, 16-bit pc, 16-bit start, registers 16-bit
const TABLE_PC=0+1;
const TABLE_START=0+3;
    const REG1 = 0 + 5;
    const REG2 = 2 + 5;
    const REG3 = 4 + 5;
    const REG4 = 6 + 5;
    const REG5 = 8 + 5;
    const REG6 = 10 + 5;
    const REG7 = 12 + 5;
    const REG8 = 14 + 5;
    const REG9 = 16 + 5;
    const REG10 = 18 + 5;
    const REG11 = 20 + 5;
    const REG12 = 22 + 5;
const memoryPage = 4096;
const memoryPageArray = 6;

    memory = new Uint8Array(1024 * 1024);
    intHandlers = new Uint8Array(256 * 5); // sleep=0/active =1, address, retaddress
    processTable = new Uint8Array(processTableEntrySize * maxProcess);
    currentProcess = 0;

    const REGINT = 1; //rint     register int support    int_number
    const INT = 2; //int      execute int             int_number, mem position, length
    const INTRET = 3; //intret   return from int
    const PROC = 4; //proc     separate and start process from memory  mem position, length
    const END = 5; //end      end process
    const JUMPBACK = 6; //jmp      jump                                    address
    const JUMPTRUE = 7; // compare register with value, when the same, jump to ....
    const JUMPFALSE = 8; //compare register with value, when not the same, jump to ...
    const CMPTRUE = 9; //cmptrue      compare register with register, when the same, jump to      address1, address2, jump
    const CMPFALSE = 10;
    const LOAD = 11; //load register from memory, start, stop, address
    const SAVE = 12; //save register to memory, start, stop, value
    const SET = 13;
    const ADD = 14; // add register with value, start, stop, value
    const DEC = 15; // decrease register with value, start, stop, value
    const DIV = 16;
    const MUL = 17;

//leftbit
//rightbit
//xor
//and
//or
//neg
//set 4bitod 4bitdo 16bit

    activeProcesses = 0;

    const NAMES = ['REGINT', 'INT', 'INTRET', 'PROC', 'END', 'JUMPBACK', 'JUMPTRUE', 'JUMPFALSE', 'CMPTRUE', 'CMPFALSE', 'LOAD', 'SAVE', 'SET', 'ADD', 'DEC', 'DIV', 'MUL'];

    function bootloader() {
        const screenProcessSize = 80*25 + 6 * bytesPerInstruction;
        const bootloaderCodeSize = 5 * bytesPerInstruction + 5+6;

        const bootloaderCode = [
            0, 0, 0, 0, 0, 0,	//memory table
            PROC, 0, 0, 0, 0, 0, //  process starts in segment 0
            PROC, 1, 0,0,0,0,//  process starts in segment 1 wylacz seg z tego procesu
            INT, 2, 0, bytesPerInstruction * 5 + 1, 0, bytesPerInstruction * 5 + 5,  // address start, share page with concrete address under concrete int page?
            END, 0, 0, 0, 0, 0,
            'h', 'a', 'l', 'l', 'o',
        ];

        const screenCode = [
	    1, 0,0,0,0,0,
            REGINT, 2, 0, 0, 0, 0, //register int 2
            CMPTRUE, 1, 2, 0, 0, 0, //if address from register 1 = address from register 2  RINT
            INTRET, 2, 0, 0, 0, 0,
            ADD, 1, 1, 0, 0, 0, // add to register 1 value 1
            JUMPBACK, 0, 3, 0, 0, 0 // jump to CMPTRUER
        ];

        const screenRAM = new Uint8Array(80*25);

        let pos = 0;
        for (i = 0; i < bootloaderCode.length; i++) {
            memory[i] = bootloaderCode[i];
        }
        for (i = memoryPage; i < screenCode.length+memoryPage; i++) {
            memory[i] = screenCode[i-memoryPage];
        }

        processTable[processTableEntrySize] = 1;
        processTable[processTableEntrySize + 2] = 6;
    }

function mmu(logical, processNum) {
tableAddress=
         processTable[processNum * processTableEntrySize + TABLE_START] * 256 + processTable[processNum * processTableEntrySize + TABLE_START+1];

return memory[tableAddress+Math.floor(logicalAddress / memoryPage)]*memoryPage+logicalAddress%memoryPage;
}

    function execute() {
        address = 0;
        while (true) {
            currentProcess++;
            if (currentProcess == maxProcess) currentProcess = 0;
            if (processTable[currentProcess * processTableEntrySize] == 0) continue;

logicalAddress = 
         processTable[currentProcess * processTableEntrySize + TABLE_PC] *256  + processTable[currentProcess * processTableEntrySize + TABLE_PC+1];
address = mmu(logicalAddress,currentProcess);
console.log("logical address "+logicalAddress+" physical "+address);
    break;
        //    address = processTable[currentProcess * processTableEntrySize + 1] * 256 + processTable[currentProcess * processTableEntrySize + 2];
    //        if (address != 0) break;
        }
        console.log("current process " + currentProcess);
        for (ins = 0; ins < 5; ins++) { // 5 instruction per process
            console.log("address = " + address + " instruction = " + memory[address] + " " + NAMES[memory[address] - 1] + " " + memory[address + 1] + " " + memory[address + 2] + " " + memory[address + 3] + " " + memory[address + 4] + " " + memory[address + 5]);
            dontIncreaseAddress = false;
            switch (memory[address]) {
                case PROC:
                    for (j = 0; j < maxProcess; j++) {
                        if (processTable[j * processTableEntrySize + 2] == 0) {
                            console.log("registering as process " + j);
                            processTable[j * processTableEntrySize] = 1; // active
//code address
                            processTable[j * processTableEntrySize + 1] = 0;
                            processTable[j * processTableEntrySize + 2] = 6;
//first page start

console.log(       (memory[address+1]*memoryPage));
    
            processTable[j * processTableEntrySize + 3] = (memory[address+1]*memoryPage)/256;
                            processTable[j * processTableEntrySize + 4] = (memory[address + 1]*memoryPage)%256;
                                
                            activeProcesses++;
                            break;
                        }
                    }
                    break;
                case REGINT:
                    if (intHandlers[memory[address + 1] * 5 + 2] == 0) {
                        console.log("registering int " + memory[address + 1] + " " + address);
                        intHandlers[memory[address + 1] * 5 + 1] = (address + 6) / 256;
                        intHandlers[memory[address + 1] * 5 + 2] = (address + 6) % 256;
                        processTable[currentProcess * processTableEntrySize] = 0; // sleepy, sleepy
                        activeProcesses--;
                    }
                    break;
                case INT:
                    dontIncreaseAddress = true;
                    if (intHandlers[memory[address + 1] * 5 + 2] != 0) {
                        intHandlers[memory[address + 1] * 5 + 3] = (address + 6) / 256;
                        intHandlers[memory[address + 1] * 5 + 4] = (address + 6) % 256;
                        console.log("return address " + (address + 6));
        processTable[currentProcess * processTableEntrySize + 1] = logicalAddress / 256;
        processTable[currentProcess * processTableEntrySize + 2] = logicalAddress % 256;
                        address = intHandlers[memory[address + 1] * 5 + 1] * 256 + intHandlers[memory[address + 1] * 5 + 2]; // jump to int handler
                        console.log("jump to address " + address);
                        intHandlers[memory[address + 1] * 5] = 1;
                    }
                    break;
                case END:
                    processTable[currentProcess * processTableEntrySize + 6] = 0;
                    activeProcesses--;
                    if (activeProcesses == 0) return;
                    break;
                case INTRET:
                    dontIncreaseAddress = true;
                    address = intHandlers[memory[address + 1] * 5 + 3] * 256 + intHandlers[memory[address + 1] * 5 + 4];
                    console.log("return address " + address);
                    intHandlers[memory[address + 1] * 5 + 3] = 0;
                    intHandlers[memory[address + 1] * 5 + 4] = 0;
                    intHandlers[memory[address + 1] * 5] = 0; //not active
                    break;
                case JUMPBACK:
                    address -= (memory[address + 1] * 256 + memory[address + 2]) * bytesPerInstruction;
                    break;
                case CMPTRUE:
                    console.log("comparing " + processTable[currentProcess * processTableEntrySize + 6 + memory[address + 1]] + " " +
                        processTable[currentProcess * processTableEntrySize + 6 + memory[address + 2]]);
                    if (processTable[currentProcess * processTableEntrySize + 6 + memory[address + 1] + 1] !=
                        processTable[currentProcess * processTableEntrySize + 6 + memory[address + 2] + 1]) {
                        logicalAddress += bytesPerInstruction;
                    }
                    break;
            }
            if (!dontIncreaseAddress) {
                logicalAddress += bytesPerInstruction;
address = mmu(logicalAddress,currentProcess);
            }
            // if process is sleepy go into next task
            if (processTable[currentProcess * processTableEntrySize] == 0) break;
        }
        // save address back into process info
        // we need stack
        processTable[currentProcess * processTableEntrySize + 1] = logicalAddress / 256;
        processTable[currentProcess * processTableEntrySize + 2] = logicalAddress % 256;
    }

    bootloader();

    for (i = 0; i < 10; i++) {
        execute();
        if (activeProcesses == 0) break;
    }
</script>

</html>