<!DOCTYPE html>
<html>

<head>
    <title>PL1 240215</title>
</head>

<body>
    <div id=info></div>
    <p>
    <div id=terminal></div>
</body>

<script>
    const debugLevel = 0;
    instructions = 0;
    MMUcache = 0;
    MMUother = 0;
    MMUnew = 0;

    const memoryPageNumber = 256;
    const memoryPageSize = 256;
    const memorySize = memoryPageSize * memoryPageNumber;
    memory = new Uint8Array(memorySize); // DRAM RAM
    mmuTable = new Uint8Array(memoryPageNumber * 2); // SRAM in MMU  //in every entry: processNum, logicalPageNum
    lastMMUSearch = 0;

    intHandlers = new Uint8Array(256 * 4); //L1 cache? SRAM memory // in every entry: sleep=1/active =2, handler process num, handler 16-bit logic address
    portInHandlers = new Uint8Array(256 * 3); //L1 cache? SRAM memory // in every entry: handler process num, handler 16-bit logic address
    keyboardInput = "";

    const maxProcess = 100;
    const registerNum = 12;
    const processTableIndexEntrySize = 3;
    processTableIndex = new Uint8Array(maxProcess * processTableIndexEntrySize); // L1 cache? SRAM memory //in every entry: sleep=1/active =2, link to processTableDetails, intReturnProcessNumber for processTableDetails during int
    const TABLE1_ACTIVE = 0;
    const TABLE1_PROCESS_NUM = 1;
    const TABLE1_INTRET_PROCESS_NUM = 2;
    const processTableDetailsEntrySize = 2 + 2 + 2 + registerNum * 2; // 16-bit logical code address, 
    //16 bit logical data address, 16 bit logical stack address, registers 16-bit
    processTableDetails = new Uint8Array(processTableDetailsEntrySize * maxProcess); //L1 cache? SRAM memory
    const TABLE2_CODE = 0;
    const TABLE2_DATE = 2;
    const TABLE2_STACK = 4;
    const TABLE2_REG = 6;
    const TABLE2_REG1 = 6;
    const TABLE2_REG2 = 8;
    const TABLE2_REG3 = 10;
    const TABLE2_REG4 = 12;
    const TABLE2_REG5 = 14;
    const TABLE2_REG6 = 16;
    const TABLE2_REG7 = 18;
    const TABLE2_REG8 = 20;
    const TABLE2_REG9 = 22;
    const TABLE2_REG10 = 24;
    const TABLE2_REG11 = 26;
    const TABLE2_REG12 = 28;
    currentProcessIndex = 0; //1-256
    activeProcesses = 0;

    const bytesPerInstruction = 5;
    const REGINT = 1; //rint     register int support    int_number
    const INT = 2; //int      execute int             int_number, mem position, length
    const INTRET = 3; //intret   return from int
    const PROC = 4; //proc     separate and start process from memory  mem position, length
    const END = 5; //end      end process
    const JUMPBACK = 6; //jmp      jump                                    address
    const JUMPTRUE = 7; // compare register with value, when the same, jump to ....
    const JUMPFALSE = 8; //compare register with value, when not the same, jump to ...
    const CMPTRUE = 9; //cmptrue      compare register with register, when the same, jump to      address1, address2, jump
    const CMPFALSE = 10;
    const LOADFROMRAM = 11; //load register from memory, start, stop, address
    const SAVETORAM = 12; //save register to memory, start, stop, value
    const SET = 13; //set 4bitod 4bitdo 16bit
    const ADD = 14; // add register with value, start, stop, value
    const DEC = 15; // decrease register with value, start, stop, value
    const DIV = 16;
    const MUL = 17;
    //leftbit
    //rightbit
    //xor
    //and
    //or
    //neg
    //neg2 
    const FREERAMBLOCK = 18;
    const OUTPORT = 19;
    const INPORT = 20;
    const REGINPORT = 21;
    const INPORTRET = 22;
    const JUMP = 23;
    const NAMES = ['REGINT', 'INT', 'INTRET', 'PROC', 'END', 'JUMPBACK', 'JUMPTRUE', 'JUMPFALSE', 'CMPTRUE', 'CMPFALSE', 'LOADFROMRAM', 'SAVETORAM', 'SET', 'ADD', 'DEC', 'DIV', 'MUL', 'FREERAMBLOCK', 'OUTPORT', 'INPORT', 'REGINPORT', 'INPORTRET', 'JUMP'];

    function bootloader() {
        const bootloaderCode = [
            PROC, 2, 0, 0, 0, //  screen code process starts in segment 2
            PROC, 3, 0, 0, 0, //  keyboard code process starts in segment 3
            INT, 2, 1, 0, 0, // int with number 2 and segment 1
            END, 0, 0, 0, 0
        ];

        const bootloaderData = "Szesnastobitowe pozdrowienia z ekranu dla Michala!!!\n" + document.title + "\nHello world!\nPress character key to see magic\n";

        const screenCode = [
            REGINT, 2, 0, 0, 0, //register int 2
            SET, 1, 1, memoryPageNumber - 1, 0, //set registers 1-1 to value memoryPageNumber*256+0
            LOADFROMRAM, 2, 2, 1, 0, //load to registers 2-2 value from address specified in register 1
            CMPTRUE, 2, 0, 0, 0, //if value from register 2 = 0 then INTRET
            INTRET, 0, 0, 0, 0,
            OUTPORT, 1, 2, 0, 0, //write to port 1 value from register 2
            ADD, 1, 1, 0, 1, // add 1 to registers 1-1
            JUMPBACK, 0, 5, 0, 0 // jump to SET
        ];

        const keyboardCode = [
            REGINPORT, 1, 0, 0, 0, //register input port 1
            SET, 1, 1, 1, 0, //set registers 1-1 to value 1*256+0
            INPORT, 1, 2, 2, 0, //read port 1 to registers 2-2
            CMPTRUE, 2, 0, 0, 0, //if value from register 2 = 0 then JUMP
            JUMP, 0, 4, 0, 0,
            SAVETORAM, 2, 2, 1, 0, //save registers 2-2 to memory starting from address in register 1
            ADD, 1, 1, 0, 1, // add 1 to registers 1-1
            JUMPBACK, 0, 5, 0, 0, // jump to SET
            SAVETORAM, 2, 2, 1, 0, //save registers 2-2 to memory starting from address in register 1            
            INT, 2, 1, 0, 0, // int with number 2 and segment 1
            INPORTRET, 0, 0, 0, 0
        ];

        for (i = 0; i < bootloaderCode.length; i++) {
            memory[i] = bootloaderCode[i];
        }
        for (i = 0; i < bootloaderData.length; i++) {
            memory[i + memoryPageSize] = bootloaderData.charCodeAt(i);
        }
        for (i = 0; i < screenCode.length; i++) {
            memory[i + memoryPageSize * 2] = screenCode[i];
        }
        for (i = 0; i < keyboardCode.length; i++) {
            memory[i + memoryPageSize * 3] = keyboardCode[i];
        }

        //registration for the whole bootloader process, split for screenCode and keyboardCode will be done later

        processTableIndex[processTableIndexEntrySize] = 2; //active
        processTableIndex[processTableIndexEntrySize + 1] = 1; //index

        mmuTable[0 * 2] = 1; // process num
        mmuTable[0 * 2 + 1] = 0; //page num
        mmuTable[1 * 2] = 1;
        mmuTable[1 * 2 + 1] = 1;
        mmuTable[2 * 2] = 1;
        mmuTable[2 * 2 + 1] = 2;

        activeProcesses++;
    }

    // translation from logical to physical address. No virtual memory in this moment.
    function mmu(logicalAddress, processNum) {
        logicalPageNum = Math.floor(logicalAddress / memoryPageSize);
        if (mmuTable[lastMMUSearch * 2] == processNum && mmuTable[lastMMUSearch * 2 + 1] == logicalPageNum) {
            if (debugLevel == 2) {
                console.log("logical address1 " + logicalAddress + " physical " +
                    (lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize) + " process " + processNum);
            }
            MMUcache++;
            return lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize;
        }
        for (let s = 0; s < memoryPageNumber; s++) {
            if (mmuTable[s * 2] == processNum && mmuTable[s * 2 + 1] == logicalPageNum) {
                lastMMUSearch = s;
                if (debugLevel == 2) {
                    console.log("logical address2 " + logicalAddress + " physical " +
                        (lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize) + " process " + processNum);
                }
                MMUother++;
                return lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize;
            }
        }
        // improve with saving available pages in bytes with bits (bit setup = page used)
        for (let s = 0; s < memoryPageNumber; s++) {
            if (mmuTable[s * 2] == 0) {
                lastMMUSearch = s;
                mmuTable[lastMMUSearch * 2] = processNum;
                mmuTable[lastMMUSearch * 2 + 1] = logicalPageNum;
                if (debugLevel == 2) {
                    console.log("logical address3 " + logicalAddress + " physical " +
                        (lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize) + " process " + processNum);
                }
                MMUnew++;
                return lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize;
            }
        }
        //support for no memory unavailable situation
    }

    function showInfo() {
        document.getElementById('info').innerHTML = "last process " + currentProcess + 
", active " + activeProcesses + 
", instructions run " + instructions + 
", MMU hit " + MMUcache + ", MMU miss " + MMUother +
", MMU new alloc "+MMUnew;
    }

    function execute() {
        endloop = 0;
        while (true) {
            currentProcessIndex++;
            if (currentProcessIndex == maxProcess) {
                currentProcessIndex = 1;
                endloop++;
                if (endloop == 5) {
                    console.log("something wrong");
                    return;
                }
            }
            if (processTableIndex[currentProcessIndex * processTableIndexEntrySize] < 2) continue;
            break;
        }
        currentProcess = processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_PROCESS_NUM];
        if (debugLevel > 0) console.log("current process " + currentProcessIndex + " current process index " + currentProcess);

        logicalAddress =
            processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_CODE] * 256 +
            processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_CODE + 1];

        instruction = new Uint8Array(bytesPerInstruction);

        for (ins = 0; ins < 5; ins++) { // 5 instruction per process
            for (j = 0; j < bytesPerInstruction; j++) {
                instruction[j] = memory[mmu(logicalAddress + j, currentProcess)];
            }

            console.log("process " + currentProcess + " logical address = " + logicalAddress + " instruction = " + instruction[0] + " " +
                NAMES[instruction[0] - 1] + " " + instruction[1] + " " + instruction[2] + " " +
                instruction[3] + " " + instruction[4]);

            increaseAddress = true;
            switch (instruction[0]) {
                case PROC: // create new process
                    for (j = 1; j < maxProcess; j++) {
                        if (processTableIndex[j * processTableIndexEntrySize + TABLE1_ACTIVE] == 0) {
                            console.log("registering as process " + j);
                            processTableIndex[j * processTableIndexEntrySize + TABLE1_ACTIVE] = 2; // active
                            processTableIndex[j * processTableIndexEntrySize + TABLE1_PROCESS_NUM] = j;
                            processTableIndex[j * processTableIndexEntrySize + TABLE1_INTRET_PROCESS_NUM] = 0;

                            //logical pc address
                            processTableDetails[j * processTableDetailsEntrySize + TABLE2_CODE] = 0;
                            processTableDetails[j * processTableDetailsEntrySize + TABLE2_CODE + 1] = 0;

                            //reassign first page to new process
                            for (s = 0; s < memoryPageNumber; s++) {
                                if (mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] == instruction[1]) {
                                    mmuTable[s * 2] = j;
                                    mmuTable[s * 2 + 1] = 0;
                                    break;
                                }
                            }

                            activeProcesses++;
                            if (debugLevel > 0) console.log("active processes " + activeProcesses);
                            break;
                        }
                    }
                    break;
                case END: // end current process
                    processTableIndex[currentProcessIndex * processTableIndexEntrySize] = 0;
                    activeProcesses--;
                    if (debugLevel > 0) console.log("active processes " + activeProcesses);
                    showInfo();
                    if (activeProcesses == 0) return;
                    break;
                case REGINT: // register int handling
                    if (intHandlers[instruction[1] * 4] == 0) {
                        //console.log("registering int " + instruction[1] + " " + (logicalAddress + 6));
                        intHandlers[instruction[1] * 4] = 1; // sleepy
                        intHandlers[instruction[1] * 4 + 1] = currentProcess;
                        intHandlers[instruction[1] * 4 + 2] = (logicalAddress + bytesPerInstruction) / 256;
                        intHandlers[instruction[1] * 4 + 3] = (logicalAddress + bytesPerInstruction) % 256;

                        processTableIndex[currentProcess * processTableIndexEntrySize + TABLE1_ACTIVE] = 1; // sleepy, sleepy
                        activeProcesses--;
                        if (debugLevel > 0) console.log("active processes " + activeProcesses);
                    }
                    break;
                case INT: //execute int
                    if (intHandlers[instruction[1] * 4] != 0) {
                        // save current address
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_CODE] = (logicalAddress + bytesPerInstruction) / 256;
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_CODE + 1] = (logicalAddress + bytesPerInstruction) % 256;
                        //save process num
                        processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_INTRET_PROCESS_NUM] = currentProcess;
                        processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_PROCESS_NUM] = intHandlers[instruction[1] * 4 + 1];
                        console.log("int from process " + currentProcess + " to " + intHandlers[instruction[1] * 4 + 1] + " address " + (intHandlers[instruction[1] * 4 + 2] * 256 + intHandlers[instruction[1] * 4 + 3]));

                        //force mmu to generate page
                        mmu(instruction[2] * memoryPageNumber, currentProcess);
                        //assign page to int process with page memoryPageNumber-1
                        for (s = 0; s < memoryPageNumber; s++) {
                            if (mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] == instruction[2]) {
                                //todo: saving somewhere old data
                                mmuTable[s * 2] = intHandlers[instruction[1] * 4 + 1];
                                mmuTable[s * 2 + 1] = memoryPageNumber - 1;
                                if (debugLevel == 2) console.log("reassigning segment " + s + " to process " + intHandlers[instruction[1] * 4 + 1] + " and logical " + (memoryPageNumber - 1));
                                break;
                            }
                        }

                        //switch to new values
                        currentProcess = intHandlers[instruction[1] * 4 + 1];
                        logicalAddress = intHandlers[instruction[1] * 4 + 2] * 256 + intHandlers[instruction[1] * 4 + 3];
                        intHandlers[instruction[1] * 4] = 2; //active
                    }
                    increaseAddress = false;
                    break;
                case INTRET: // return from int execution
                    increaseAddress = false;
                    console.log("returning to process " + processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_INTRET_PROCESS_NUM]);
                    //restore process num
                    processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_PROCESS_NUM] =
                        processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_INTRET_PROCESS_NUM];
                    // we're not in int/Cansas anymore
                    processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_INTRET_PROCESS_NUM] = 0;
                    //remove shared memory
                    for (s = 0; s < memoryPageNumber; s++) {
                        //do it correctly by restoring old data
                        if (mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] != 0) {
                            console.log("removing page");
                            mmuTable[s * 2] = 0;
                            mmuTable[s * 2 + 1] = 0;
                            break;
                        }
                    }

                    //switch to new values
                    currentProcess = processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_PROCESS_NUM];
                    logicalAddress =
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_CODE] * 256 +
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_CODE + 1];
                    if (debugLevel > 0) console.log("logical address " + logicalAddress);
                    break;
                case JUMPBACK:
                    logicalAddress -= (instruction[1] * 256 + instruction[2]) * bytesPerInstruction;
                    increaseAddress = false;
                    break;
                case JUMP:
                    logicalAddress += (instruction[1] * 256 + instruction[2]) * bytesPerInstruction;
                    increaseAddress = false;
                    break;
                case ADD:
                    value1 = instruction[3] * 256 + instruction[4];

                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        value2 = processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 - 2] * 256 +
                            processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 + 1 - 2];
                        if (debugLevel > 0) console.log("value" + value1 + " " + value2);
                        value2 += value1;
                        if (debugLevel > 0) console.log("value" + value1 + " " + value2 + " " + (TABLE2_REG + j * 2 - 2));

                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 - 2] = value2 / 256;
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 + 1 - 2] = value2 % 256;
                    }
                    break;
                case SET:
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 - 2] = instruction[3];
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 + 1 - 2] = instruction[4];
                        if (debugLevel == 2) console.log("register address " + (TABLE2_REG + j * 2 - 2) + " " + instruction[3] * 256 + instruction[4]);
                    }
                    break;
                case LOADFROMRAM:
                    address = processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + instruction[3] * 2 - 2] * 256 +
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + instruction[3] * 2 + 1 - 2];
                    //console.log("logical address " + address/256+" "+address%256);
                    //console.log(mmu(address, currentProcess));
                    value = memory[mmu(address, currentProcess)];
                    //console.log("value " + value);
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        console.log("target register address " + (TABLE2_REG + j * 2 - 2) + " value " + value);
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 - 2] = value / 256;
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 + 1 - 2] = value % 256;
                    }
                    break;
                case SAVETORAM:
                    address = processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + instruction[3] * 2 - 2] * 256 +
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + instruction[3] * 2 + 1 - 2];
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        memory[mmu(address, currentProcess)] =
                            processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 + 1 - 2];
                        address++;
                    }
                    break;
                case CMPTRUE:
                    value1 = processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + instruction[1] * 2 - 2] * 256 +
                        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + instruction[1] * 2 + 1 - 2];
                    value2 = instruction[2] * 256 + instruction[3];
                    if (debugLevel > 0) console.log("comparing " + value1 + " " + value2);
                    if (value1 != value2) {
                        logicalAddress += bytesPerInstruction;
                    }
                    break;
                case OUTPORT:
                    if (instruction[1] == 1) { // terminal screen
                        value = processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + instruction[2] * 2 - 2] * 256 + processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + instruction[2] * 2 - 2 + 1];
                        if (value == 10) {
                            document.getElementById('terminal').innerHTML = document.getElementById('terminal').innerHTML + "<br>";
                        } else {
                            document.getElementById('terminal').innerHTML = document.getElementById('terminal').innerHTML + String.fromCharCode(value);
                        }
                    }
                    break;
                case REGINPORT:
                    if (portInHandlers[instruction[1] * 3] == 0) {
                        portInHandlers[instruction[1] * 3 + 0] = currentProcess;
                        portInHandlers[instruction[1] * 3 + 1] = (logicalAddress + bytesPerInstruction) / 256;
                        portInHandlers[instruction[1] * 3 + 2] = (logicalAddress + bytesPerInstruction) % 256;
                        processTableIndex[currentProcess * processTableIndexEntrySize + TABLE1_ACTIVE] = 1; // sleepy, sleepy
                        activeProcesses--;
                        if (debugLevel > 0) console.log("active processes " + activeProcesses);
                    }
                    break;
                case INPORT:
                    if (instruction[1] == 1) { //keyboard
                        code = 0;
                        if (keyboardInput.length > 0) {
                            code = keyboardInput.charCodeAt(keyboardInput.length - 1);
                            keyboardInput = keyboardInput.substring(0, keyboardInput - 1);
                            console.log(code + " " + keyboardInput);
                        }
                        for (j = instruction[2]; j <= instruction[3]; j++) {
                            processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 - 2] = code / 256;
                            processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_REG + j * 2 + 1 - 2] = code % 256;
                        }
                    }
                    break;
                case INPORTRET:
                    processTableIndex[currentProcess * processTableIndexEntrySize + TABLE1_ACTIVE] = 1; // sleepy, sleepy
                    activeProcesses--;
                    if (debugLevel > 0) console.log("active processes " + activeProcesses);
                    break;
            }
            if (increaseAddress) {
                logicalAddress += bytesPerInstruction;
            }
            instructions++;
            showInfo();
            // if process is sleepy go into next task
            if (processTableIndex[currentProcess * processTableIndexEntrySize + TABLE1_ACTIVE] == 1) break;
        }
        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_CODE] = (logicalAddress) / 256;
        processTableDetails[currentProcess * processTableDetailsEntrySize + TABLE2_CODE + 1] = (logicalAddress) % 256;
    }

    bootloader();

    while (true) {
        execute();
        if (activeProcesses == 0) {
            console.log("sleeping");
            // todo: flushing all int support code
            break;
        }
    }

    function keyUpFunction(event) {
        keyboardInput = keyboardInput + String.fromCharCode(event.which);
        //FIXME: masked-unmasked
        console.log(keyboardInput);
        processTableIndex[portInHandlers[1 * 3] * processTableIndexEntrySize + TABLE1_ACTIVE] = 2; //active
        processTableDetails[portInHandlers[1 * 3] * processTableDetailsEntrySize + TABLE2_CODE] = portInHandlers[1 * 3 + 1];
        processTableDetails[portInHandlers[1 * 3] * processTableDetailsEntrySize + TABLE2_CODE + 1] = portInHandlers[1 * 3 + 2];
        activeProcesses++;
        while (true) {
            execute();
            if (activeProcesses == 0) {
                // todo: flushing all int support code
                console.log("sleeping");
                break;
            }
        }
    }

    window.addEventListener('keyup', keyUpFunction.bind(this), false);
</script>

</html>