<!DOCTYPE html>
<html>

<head>
    <title>PL1 240215</title>
</head>

<body>
    <div id=info></div>
    <p>
    <div id=terminal></div>
</body>

<script>
    const debugLevel = 0;
    verywrong = false;
    instructions = 0;
    MMUcache = 0;
    MMUother = 0;
    MMUnew = 0;
    diskRead=0;

    const memoryPageNumber = 128;
    const memoryPageSize = 512;
    const memorySize = memoryPageSize * memoryPageNumber;
    memory = new Uint8Array(memorySize); // DRAM RAM
    mmuTable = new Uint8Array(memoryPageNumber * 2); // SRAM in MMU  //in every entry: processNum, logicalPageNum
    lastMMUSearch = 0;
    
    const addressForInt = (memoryPageNumber - 2)*memoryPageSize;
    const addressForInt2 = (memoryPageNumber - 1)*memoryPageSize;

    const intHandlerEntrySize = 4;
    intHandlers = new Uint8Array(256 * intHandlerEntrySize); //L1 cache? SRAM memory // in every entry: sleep=1/active =2, handler process num, handler 16-bit logic address

    const portInHandlerSize = 3;
    portInHandlers = new Uint8Array(256 * portInHandlerSize); //L1 cache? SRAM memory // in every entry: handler process num, handler 16-bit logic address
    keyboardInput = "";

    disk = new Uint8Array(256 * 256 * 256);
    diskReadAddress = 0;

    const maxProcess = 100;
    const registerNum = 12;
    const processTableIndexEntrySize = 6;
    processTableIndex = new Uint8Array(maxProcess * processTableIndexEntrySize); // L1 cache? SRAM memory //in every entry: sleep=1/active =2, link to processTableDetails, intReturnProcessNumber for processTableDetails during int, intNumber, intMemoryPage, intMemoryPage2
    const TABLE1_ACTIVE = 0;
    const TABLE1_PROCESS_NUM = 1;
    const TABLE1_INTRET_PROCESS_NUM = 2;
    const TABLE1_INTNUM = 3;
    const TABLE1_INTMEMPAGE = 4;
    const TABLE1_INTMEMPAGE2 = 5;
    const processTableDetailsEntrySize = 2 + 2 + 2 + registerNum * 2; // 16-bit logical code address, 
    //16 bit logical data address, 16 bit logical stack address, registers 16-bit
    processTableDetails = new Uint8Array(processTableDetailsEntrySize * maxProcess); //L1 cache? SRAM memory
    const TABLE2_CODE = 0 + 20;
    const TABLE2_DATE = 2 + 20;
    const TABLE2_STACK = 4 + 20;
    const TABLE2_REG = 6 + 20;
    currentProcessIndex = 0; //1-256
    activeProcesses = 0;

    const bytesPerInstruction = 5;
    const REGINT = 1; //rint     register int support    int_number
    const INT = 2; //int      execute int             int_number, mem position, length
    const INTRET = 3; //intret   return from int
    const PROC = 4; //proc     separate and start process from memory  mem position, length
    const END = 5; //end      end process
    const JUMPBACK = 6; //jmp      jump                                    address
    const JUMPTRUE = 7; // compare register with value, when the same, jump to ....
    const JUMPFALSE = 8; //compare register with value, when not the same, jump to ...
    const CMPTRUE = 9; //cmptrue      compare register with register, when the same, jump to      address1, address2, jump
    const CMPFALSE = 10;
    const LOADFROMRAM8 = 11; //load register from memory, start, stop, address
    const SAVETORAM8 = 12; //save register to memory, start, stop, value
    const SET = 13; //set 4bitod 4bitdo 16bit
    const ADD = 14; // add register with value, start, stop, value
    const DEC = 15; // decrease register with value, start, stop, value
    const DIV = 16;
    const MUL = 17;
    //leftbit
    //rightbit
    //xor
    //and
    //or
    //neg
    //neg2 
    const FREERAMBLOCK = 18;
    const OUTPORT = 19;
    const INPORT = 20;
    const REGINPORT = 21;
    const INPORTRET = 22;
    const JUMPPLUS = 23;
    const LOADFROMRAM16 = 24;
    const NAMES = ['REGINT', 'INT', 'INTRET', 'PROC', 'END', 'JUMPBACK', 'JUMPTRUE', 'JUMPFALSE', 'CMPTRUE', 'CMPFALSE', 'LOADFROMRAM8', 'SAVETORAM8', 'SET', 'ADD', 'DEC', 'DIV', 'MUL', 'FREERAMBLOCK', 'OUTPORT', 'INPORT', 'REGINPORT', 'INPORTRET', 'JUMPPLUS', 'LOADFROMRAM16'];

    function bootloader() {
    const maxFilesInDisk = 10;
    const maxFileSize = 512;
    if (memorySize>256*256) {
    		console.log("16 bit registers allow for addresing max. "+(256*256) +" big RAM");
    		return;
    	}
    	
        const bootloaderCode = [
            PROC, 2, 0, 0, 0, //  screen code process starts in segment 2
            PROC, 3, 0, 0, 0, //  keyboard code process starts in segment 3
            PROC, 4, 0, 0, 0, //  disk code process starts in segment 4
            INT, 2, 1, 0, 0, // int with number 2 and segment 1 - we write initial info on the screen
         
            // read text file from disk
            SET, 1, 1, 5*memoryPageSize/256, 5*memoryPageSize%256, //set registers 1-1 to value 5*256+0   //address
            SET, 2, 2, 0, 3, //set registers 2-2 to value 3         //function 3   
            SAVETORAM8, 2, 2, 1, 0, //save value of registers 2-2 to memory starting from address in register 1  
            SET, 1, 1, (5*memoryPageSize+1)/256, (5*memoryPageSize+1)%256, //set registers 1-1 to value 5*256+1 // address
            SET, 2, 2, 0, 1, //set registers 2-2 to value 1 //file number 1 from range 0-x          
            SAVETORAM8, 2, 2, 1, 0, //save value of registers 2-2 to memory starting from address in register 1                      
            INT, 3, 5, 0, 0, // int with number 3 and segment 5 - disk read
            INT, 2, 5, 0, 0, // int with number 2 and segment 5 - write output on the screen
          
            //read and start program from disk
            SET, 1, 1, 5*memoryPageSize/256, 5*memoryPageSize%256, //set registers 1-1 to value 5*256+0   //address
            SET, 2, 2, 0, 4, //set registers 2-2 to value 3         //function 3   
            SAVETORAM8, 2, 2, 1, 0, //save value of registers 2-2 to memory starting from address in register 1  
            SET, 1, 1, (5*memoryPageSize+1)/256, (5*memoryPageSize+1)%256, //set registers 1-1 to value 5*256+1 // address
            SET, 2, 2, 0, 2, //set registers 2-2 to value 1 //file number 1 from range 0-x          
            SAVETORAM8, 2, 2, 1, 0, //save value of registers 2-2 to memory starting from address in register 1                      
            INT, 3, 5, 6, 0, // int with number 3 and segment 5 - disk read
            PROC, 5, 6, 0, 0, //  disk code process starts in segment 4
            END, 0, 0, 0, 0
        ];

        const bootloaderData = "Szesnastobitowe pozdrowienia z ekranu dla Michala!!!\n" + document.title + "\nHello world!\nPress character key to see magic\n";

        const screenCode = [
            REGINT, 2, 0, 0, 0, //register int 2
            SET, 1, 1, addressForInt/256, addressForInt%256, //set registers 1-1 to value memoryPageNumber*256+0
            LOADFROMRAM8, 2, 2, 1, 0, //load to registers 2-2 value from address specified in register 1
            CMPTRUE, 2, 0, 0, 0, //if value from register 2 = 0 then INTRET
            INTRET, 0, 0, 0, 0,
            OUTPORT, 1, 2, 0, 0, //write to port 1 value from register 2
            ADD, 1, 1, 0, 1, // add 1 to registers 1-1
            JUMPBACK, 0, 5, 0, 0 // jump to SET
        ];

        const keyboardCode = [
            REGINPORT, 1, 0, 0, 0, //register input port 1
            SET, 1, 1, memoryPageSize/256, memoryPageSize%256, //set registers 1-1 to value 1*256+0
            INPORT, 1, 2, 2, 0, //read port 1 to registers 2-2
            CMPTRUE, 2, 0, 0, 0, //if value from register 2 = 0 then JUMP
            JUMPPLUS, 0, 4, 0, 0,
            SAVETORAM8, 2, 2, 1, 0, //save registers 2-2 to memory starting from address in register 1
            ADD, 1, 1, 0, 1, // add 1 to registers 1-1
            JUMPBACK, 0, 5, 0, 0, // jump to SET
            SAVETORAM8, 2, 2, 1, 0, //save registers 2-2 to memory starting from address in register 1            
            INT, 2, 1, 0, 0, // int with number 2 and segment 1
            INPORTRET, 0, 0, 0, 0
        ];

        const diskReaderCode = [
            REGINT, 3, 0, 0, 0, //register int 3
            SET, 1, 1, addressForInt/256, addressForInt%256, //set registers 1-1 to value memoryPageNumber*256+0
            LOADFROMRAM8, 2, 2, 1, 0, //load to registers 2-2 value from address specified in register 1
            
            //get file number
            CMPTRUE, 2, 0, 1, 0, //if value from register 2 = 1 then jump plus 2 & get file num
            JUMPPLUS, 0, 2, 0, 0,
            JUMPPLUS, 0, 6, 0, 0,
            SET, 2, 2, 0, 0, //set registers 1-1 to value 0
            OUTPORT, 2, 2, 0, 0, //write to port 2 value from register 2
            INPORT, 2, 3, 3, 0, //read port 2 to registers 3-3
            SAVETORAM8, 3, 3, 1, 0, //save registers 2-2 to memory starting from address in register 1
            INTRET, 0, 0, 0, 0,
            
            //get file name
            CMPTRUE, 2, 0, 2, 0, //if value from register 2 = 2 then jumpplus & get file name
            JUMPPLUS, 0, 2, 0, 0,
            JUMPPLUS, 0, 13, 0, 0,
            SET, 1, 1, (addressForInt+1)/256, (addressForInt+1)%256, //set registers 1-1 to value memoryPageNumber*256+0            
            LOADFROMRAM8, 2, 2, 1, 0, //load to registers 2-2 value from address specified in register 1
            SET, 1, 1, addressForInt/256, addressForInt%256, //set registers 1-1 to value memoryPageNumber*256+0                       
            MUL, 2, 2, 0, 11,
            ADD, 2, 2, 0, 1, // add 1 to registers 1-1
            OUTPORT, 2, 2, 0, 0, //write to port 2 value from register 2            
            INPORT, 2, 3, 3, 0, //read port 2 to registers 3-3
            SAVETORAM8, 3, 3,1,0, //save registers 2-2 to memory starting from address in register 1
            CMPTRUE, 3, 0, 0, 0, //if value from register 2 = 0 then jump plus 2 & get file num            
            INTRET, 0, 0, 0, 0,
            ADD, 1, 1, 0, 1, // add 1 to registers 1-1            
            JUMPBACK, 0, 7, 0,0     ,
            
            //get text file content
            CMPTRUE, 2, 0, 3, 0, //if value from register 2 = 3 then jumpplus & get file content
            JUMPPLUS, 0, 2, 0, 0,
            JUMPPLUS, 0, 14, 0, 0,
            SET, 1, 1, (addressForInt+1)/256, (addressForInt+1)%256, //set registers 1-1 to value memoryPageNumber*256+0            
            LOADFROMRAM8, 2, 2, 1, 0, //load to registers 2-2 value from address specified in register 1  //this is file number 0,1 or 2
            SET, 1, 1, addressForInt/256, addressForInt%256, //set registers 1-1 to value memoryPageNumber*256+0                                  
            MUL, 2, 2, maxFileSize/256, maxFileSize%256,  // 2*256 = 512 = size of every single file
            ADD, 2, 2, 0, 11*maxFilesInDisk, // 3*9 = 27 = size of file table
            ADD, 2, 2, 0, 1, // add 1 to registers 1-1
            OUTPORT, 2, 2, 0, 0, //write to port 2 value from register 2            
            INPORT, 2, 3, 3, 0, //read port 2 to registers 3-3
            SAVETORAM8, 3, 3, 1, 0, //save registers 2-2 to memory starting from address in register 1
            CMPTRUE, 3, 0, 0, 0, //if value from register 3 = 0 then int ret            
            INTRET, 0, 0, 0, 0,
            ADD, 1, 1, 0, 1, // add 1 to registers 1-1            
            JUMPBACK, 0, 7, 0,0    ,
            
            //get binary file content
            CMPTRUE, 2, 0, 4, 0, //if value from register 2 = 3 then jumpplus & get file content
            JUMPPLUS, 0, 2, 0, 0,
            INTRET, 0, 0, 0, 0,
            SET, 1, 1, (addressForInt+1)/256, (addressForInt+1)%256, //set registers 1-1 to value memoryPageNumber*256+0            
            LOADFROMRAM8, 2, 2, 1, 0, //load to registers 2-2 value from address specified in register 1  //this is file number 0,1 or 2
            MUL, 2, 2, maxFileSize/256, maxFileSize%256,  // 2*256 = 512 = size of every single file
            ADD, 2, 2, 0, 11*maxFilesInDisk, // 3*9 = 27 = size of file table
            ADD, 2, 2, 0, 1, // add 1 to registers 1-1
            OUTPORT, 2, 2, 0, 0, //write to port 2 value from register 2            
            INPORT, 2, 3, 3, 0, //read port 2 to registers 3-3   //code length
            ADD, 2, 2, 0, 1, // add 1 to registers 1-1
            OUTPORT, 2, 2, 0, 0, //write to port 2 value from register 2            
            INPORT, 2, 4, 4, 0, //read port 2 to registers 3-3   //data length            
            SET, 1, 1, addressForInt/256, addressForInt%256, //set registers 1-1 to value memoryPageNumber*256+0                                  
            ADD, 2, 2, 0, 1, // add 1 to registers 1-1
            //read binary
            OUTPORT, 2, 2, 0, 0, //write to port 2 value from register 2            
            INPORT, 2, 5, 5, 0, //read port 2 to registers 3-3   //data length            
            SAVETORAM8, 5, 5, 1, 0, //save registers 2-2 to memory starting from address in register 1
            ADD, 1, 1, 0, 1, // add 1 to registers 1-1
            ADD, 2, 2, 0, 1, // add 1 to registers 1-1
            DEC, 3, 3, 0, 1, // add 1 to registers 1-1
            CMPTRUE, 3, 0, 0, 0, //if value from register 3 = 0 then int ret            
            JUMPPLUS, 0, 2, 0, 0,
            JUMPBACK, 0, 8, 0, 0,
            //read data
            SET, 1, 1, addressForInt2/256, addressForInt2%256, //set registers 1-1 to value memoryPageNumber*256+0                                  
            CMPTRUE, 4, 0, 0, 0, //if value from register 3 = 0 then int ret            
            INTRET, 0, 0, 0, 0,
            OUTPORT, 2, 2, 0, 0, //write to port 2 value from register 2            
            INPORT, 2, 5, 5, 0, //read port 2 to registers 3-3   //data length            
            SAVETORAM8, 5, 5, 1, 0, //save registers 2-2 to memory starting from address in register 1
            ADD, 1, 1, 0, 1, // add 1 to registers 1-1
            ADD, 2, 2, 0, 1, // add 1 to registers 1-1
            DEC, 4, 4, 0, 1, // add 1 to registers 1-1
            JUMPBACK, 0, 8, 0,0          
        ];

	if (bootloaderCode.length>memoryPageSize || bootloaderData.length>memoryPageSize || screenCode.length>memoryPageSize || keyboardCode>memoryPageSize || diskReaderCode>memoryPageSize) {
		console.log("too long code");
		return;
	}
	
        for (i = 0; i < bootloaderCode.length; i++) {
            memory[i] = bootloaderCode[i];
        }
        for (i = 0; i < bootloaderData.length; i++) {
            memory[i + memoryPageSize] = bootloaderData.charCodeAt(i);
        }
        for (i = 0; i < screenCode.length; i++) {
            memory[i + memoryPageSize * 2] = screenCode[i];
        }
        for (i = 0; i < keyboardCode.length; i++) {
            memory[i + memoryPageSize * 3] = keyboardCode[i];
        }
        for (i = 0; i < diskReaderCode.length; i++) {
            memory[i + memoryPageSize * 4] = diskReaderCode[i];
        }

        //registration for the whole bootloader process, split for screenCode and keyboardCode will be done later
        changeProcessDetails(1, TABLE1_ACTIVE, 2); //active
        changeProcessDetails(1, TABLE1_PROCESS_NUM, 1);

        for (i = 0; i < 5; i++) {
            mmuTable[i * 2] = 1; // process num
            mmuTable[i * 2 + 1] = i; //page num
        }

        activeProcesses++;
        
        const fileCode = [
            INT, 2, 1, 0, 0, // int with number 2 and segment 1 - we write initial info on the screen
            END, 0, 0, 0, 0
        ];
        const fileData = "Hallo world from program from disk\n";
        
	//number of files (8 bit)
	//file1 length (16 bit) file 1 name (8+1 bytes)
	//file2 length (16 bit) file 2 name (8+1 bytes)
	//...
	//file 1 content (max 512 bytes)
	//file 2 content (max 512 bytes)
	//...
        const diskFileNames = ["file1", "two", "three"];
        const diskFileContent = ["Hello2","Hallo from text file in disk\n",""];
        disk[0] = diskFileNames.length;
        for (i = 0; i < diskFileNames.length; i++) {
            disk[1+i*11] = diskFileContent[i].length / 256;
            disk[1+i*11+1] = diskFileContent[i].length % 256;
            for (j = 0; j < diskFileNames[i].length; j++) {
                disk[1+i*11+j+2] = diskFileNames[i].charCodeAt(j);
            }
            if (i==2) {
             disk[1+i*11] = (fileCode.length+fileData.length) / 256;
            disk[1+i*11+1] = (fileCode.length+fileData.length) % 256;
            	pos = 1+maxFilesInDisk*11+i*maxFileSize;            	
            disk[pos++] = fileCode.length;
             disk[pos++] = fileData.length;
            	 for (j = 0; j < fileCode.length; j++) {
                disk[pos++] = fileCode[j];
            } 
             
            	 for (j = 0; j < fileData.length; j++) {
                disk[pos++] = fileData.charCodeAt(j);
            } 
            } else {
            for (j = 0; j < diskFileContent[i].length; j++) {
                disk[1+maxFilesInDisk*11+i*maxFileSize+j] = diskFileContent[i].charCodeAt(j);
            }  
            }
        }
        
    }

    // translation from logical to physical address. No virtual memory in this moment.
    function mmu(logicalAddress, processNum) {
        logicalPageNum = Math.floor(logicalAddress / memoryPageSize);
        if (mmuTable[lastMMUSearch * 2] == processNum && mmuTable[lastMMUSearch * 2 + 1] == logicalPageNum) {
            if (debugLevel == 2) {
                console.log("logical address1 " + logicalAddress + " physical " +
                    (lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize) + " process " + processNum);
            }
            MMUcache++;
            return lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize;
        }
        for (let s = 0; s < memoryPageNumber; s++) {
            if (mmuTable[s * 2] == processNum && mmuTable[s * 2 + 1] == logicalPageNum) {
                lastMMUSearch = s;
                if (debugLevel == 2) {
                    console.log("logical address2 " + logicalAddress + " physical " +
                        (lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize) + " process " + processNum);
                }
                MMUother++;
                return lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize;
            }
        }
        // improve with saving available pages in bytes with bits (bit setup = page used)
        for (let s = 0; s < memoryPageNumber; s++) {
            if (mmuTable[s * 2] == 0) {
                lastMMUSearch = s;
                mmuTable[lastMMUSearch * 2] = processNum;
                mmuTable[lastMMUSearch * 2 + 1] = logicalPageNum;
                if (debugLevel == 2) {
                    console.log("logical address3 " + logicalAddress + " physical " +
                        (lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize) + " process " + processNum);
                }
                MMUnew++;
                return lastMMUSearch * memoryPageSize + logicalAddress % memoryPageSize;
            }
        }
        //support for no memory unavailable situation
    }

    function changeRegister(registerNum, value) {
        changeProcessDetails(currentProcess, TABLE2_REG + (registerNum - 1) * 2, value);
    }

    function getRegister(registerNum) {
        return getProcessDetails(currentProcess, TABLE2_REG + (registerNum - 1) * 2);
    }

    function changeProcessDetails(processNum, field, value) {
        switch (field) {
            case TABLE1_ACTIVE:
            case TABLE1_PROCESS_NUM:
            case TABLE1_INTRET_PROCESS_NUM:
            case TABLE1_INTNUM:
            case TABLE1_INTMEMPAGE:
            case TABLE1_INTMEMPAGE2:
                processTableIndex[processNum * processTableIndexEntrySize + field] = value;
                return;
        }
        processTableDetails[processNum * processTableDetailsEntrySize + field - 20] = value / 256;
        processTableDetails[processNum * processTableDetailsEntrySize + field - 20 + 1] = value % 256;
    }

    function getProcessDetails(processNum, field) {
        switch (field) {
            case TABLE1_ACTIVE:
            case TABLE1_PROCESS_NUM:
            case TABLE1_INTRET_PROCESS_NUM:
            case TABLE1_INTNUM:
            case TABLE1_INTMEMPAGE:
            case TABLE1_INTMEMPAGE2:
                return processTableIndex[processNum * processTableIndexEntrySize + field];
        }
        return processTableDetails[processNum * processTableDetailsEntrySize + field - 20] * 256 +
            processTableDetails[processNum * processTableDetailsEntrySize + field - 20 + 1];
    }
    
    function showInfo() {
        used = 0;
        for (let ss = 0; ss < memoryPageNumber; ss++) {
            if (mmuTable[ss * 2] != 0) {
                used++;
            }
        }

        document.getElementById('info').innerHTML = "last process " + currentProcess +
            ", active " + activeProcesses +
            ", instructions run " + instructions +
            ", MMU hit " + MMUcache + ", MMU miss " + MMUother +
            ", MMU new alloc " + MMUnew +
            ", memory pages " + used + "/" + memoryPageNumber +
            ", bytes read from disk "+diskRead;
    }

    function dumpProcessInfo(processNum) {
        out = "process " + processNum + " ";
        for (z = 0; z < processTableIndexEntrySize; z++) {
            out += processTableIndex[processNum * processTableIndexEntrySize + z] + " ";
        }
        out += ", ";
        for (z = 0; z < processTableDetailsEntrySize; z++) {
            out += processTableDetails[processTableIndex[processNum * processTableIndexEntrySize + TABLE1_PROCESS_NUM] * processTableDetailsEntrySize + z] + " ";
        }
        console.log(out);
    }

    function execute() {
        endloop = 0;
        while (true) {
            currentProcessIndex++;
            if (currentProcessIndex == maxProcess) {
                currentProcessIndex = 1;
                endloop++;
                if (endloop == 5) {
                    console.log("something wrong");
                    return;
                }
            }
            if (getProcessDetails(currentProcessIndex, TABLE1_ACTIVE) < 2) continue;
            break;
        }
        currentProcess = getProcessDetails(currentProcessIndex, TABLE1_PROCESS_NUM);
        if (debugLevel > 0) console.log("current process index " + currentProcessIndex + " current process " + currentProcess);

        logicalAddress = getProcessDetails(currentProcess, TABLE2_CODE);

        instruction = new Uint8Array(bytesPerInstruction);

        for (ins = 0; ins < 5; ins++) { // 5 instruction per process
            for (j = 0; j < bytesPerInstruction; j++) {
            	//when memory page size aligned with bytesPerInstruction, we could calculate segment in mmu only once
                instruction[j] = memory[mmu(logicalAddress + j, currentProcess)];
            }

            console.log("process " + currentProcess + " logical address = " + logicalAddress + " instruction = " + instruction[0] + " " +
                NAMES[instruction[0] - 1] + " " + instruction[1] + " " + instruction[2] + " " +
                instruction[3] + " " + instruction[4]);

            increaseAddress = true;
            switch (instruction[0]) {
                case PROC: // create new process
                    for (j = 1; j < maxProcess; j++) {
                        if (getProcessDetails(j, TABLE1_ACTIVE) == 0) {
                            console.log("registering as process " + j);

                            changeProcessDetails(j, TABLE1_ACTIVE, 2); // active                           
                            changeProcessDetails(j, TABLE1_PROCESS_NUM, j);
                            changeProcessDetails(j, TABLE1_INTRET_PROCESS_NUM, 0);
                            //logical pc address
                            changeProcessDetails(j, TABLE2_CODE, 0);
                            //reassign first/second page to new process
                            for (s = 0; s < memoryPageNumber; s++) {
                                if (mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] == instruction[1]) {
                                    mmuTable[s * 2] = j;
                                    mmuTable[s * 2 + 1] = 0;
                                    
                                } else if (instruction[2]!=0 && mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] == instruction[2]) {
                                    mmuTable[s * 2] = j;
                                    mmuTable[s * 2 + 1] = 1;
                                    
                                }
                            }
                            activeProcesses++;
                            if (debugLevel > 0) console.log("active processes " + activeProcesses);
                            break;
                        }
                    }
                    break;
                case END: // end current process
                    changeProcessDetails(currentProcessIndex, TABLE1_ACTIVE, 0);
                    //todo: free memory in MMU and clean memory
                    activeProcesses--;
                    if (debugLevel > 0) console.log("active processes " + activeProcesses);
                    showInfo();
                    return;
                    break;
                case REGINT: // register int handling
                    if (intHandlers[instruction[1] * intHandlerEntrySize] == 0) {
                        console.log("registering int " + instruction[1] + " " + (logicalAddress + 6));
                        intHandlers[instruction[1] * intHandlerEntrySize] = 1; // sleepy
                        intHandlers[instruction[1] * intHandlerEntrySize + 1] = currentProcess;
                        intHandlers[instruction[1] * intHandlerEntrySize + 2] = (logicalAddress + bytesPerInstruction) / 256;
                        intHandlers[instruction[1] * intHandlerEntrySize + 3] = (logicalAddress + bytesPerInstruction) % 256;

                        changeProcessDetails(currentProcess, TABLE1_ACTIVE, 1); // sleepy, sleepy
                        activeProcesses--;
                        if (debugLevel > 0) console.log("active processes " + activeProcesses);
                    }
                    break;
                case INT: //execute int
                    if (intHandlers[instruction[1] * intHandlerEntrySize] == 1) {
                        console.log("executing int");
                        // save current address
                        changeProcessDetails(currentProcess, TABLE2_CODE, logicalAddress + bytesPerInstruction);
                        //save process num
                        changeProcessDetails(currentProcessIndex, TABLE1_INTRET_PROCESS_NUM, currentProcess);
                        //save int num
                        changeProcessDetails(currentProcessIndex, TABLE1_INTNUM, instruction[1]);
                        //force mmu to generate page
                        mmu(instruction[2] * memoryPageSize, currentProcess);
                        if (instruction[3]!=0) mmu(instruction[3] * memoryPageSize, currentProcess);
                        //assign page to int process with page memoryPageNumber-1
                        changeProcessDetails(currentProcessIndex, TABLE1_INTMEMPAGE2, 0);
                        for (s = 0; s < memoryPageNumber; s++) {
                            if (mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] == instruction[2]) {
                                console.log("1mmu table seg with int " + mmuTable[s * 2] + " " + mmuTable[s * 2 + 1]);
                                //todo: saving somewhere old data
                                mmuTable[s * 2] = intHandlers[instruction[1] * intHandlerEntrySize + 1];
                                changeProcessDetails(currentProcessIndex, TABLE1_INTMEMPAGE, mmuTable[s * 2 + 1]);
                                mmuTable[s * 2 + 1] = addressForInt / memoryPageSize;
                                console.log("1mmu table seg with int2 " + mmuTable[s * 2] + " " + mmuTable[s * 2 + 1]);
                               
                            }
                             else if (instruction[3]!=0 && mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] == instruction[3]) {
                                console.log("2mmu table seg with int " + mmuTable[s * 2] + " " + mmuTable[s * 2 + 1]);
                                //todo: saving somewhere old data
                                mmuTable[s * 2] = intHandlers[instruction[1] * intHandlerEntrySize + 1];
                                changeProcessDetails(currentProcessIndex, TABLE1_INTMEMPAGE2, mmuTable[s * 2 + 1]);
                                mmuTable[s * 2 + 1] = addressForInt2 / memoryPageSize;
                                console.log("2mmu table seg with int2 " + mmuTable[s * 2] + " " + mmuTable[s * 2 + 1]);
                               
                            }
                        }
                        console.log("int from process " + currentProcess + " to " + intHandlers[instruction[1] * 4 + 1] + " address " + (intHandlers[instruction[1] * 4 + 2] * 256 + intHandlers[instruction[1] * 4 + 3]));
                        //switch to new values
                        //new process
                        currentProcess = intHandlers[instruction[1] * intHandlerEntrySize + 1];
                        changeProcessDetails(currentProcessIndex, TABLE1_PROCESS_NUM, currentProcess);
                        //new address
                        logicalAddress = intHandlers[instruction[1] * intHandlerEntrySize + 2] * 256 + intHandlers[instruction[1] * intHandlerEntrySize + 3];
                        //block executing this int by other process
                        intHandlers[instruction[1] * intHandlerEntrySize] = 2; //active

                    }
                    increaseAddress = false;
                    break;
                case INTRET: // return from int execution
                    increaseAddress = false;
                    console.log("returning to process " + processTableIndex[currentProcessIndex * processTableIndexEntrySize + TABLE1_INTRET_PROCESS_NUM]);
                    //remove shared memory
                    for (s = 0; s < memoryPageNumber; s++) {
                        
                        if (mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] == addressForInt / memoryPageSize) {
                            console.log("1mmu table seg with int " + mmuTable[s * 2] + " " + mmuTable[s * 2 + 1]);
                            console.log("removing page");
                            mmuTable[s * 2] = getProcessDetails(currentProcessIndex, TABLE1_INTRET_PROCESS_NUM);
                            mmuTable[s * 2 + 1] = getProcessDetails(currentProcessIndex,  TABLE1_INTMEMPAGE);
                            console.log("1mmu table seg with int " + mmuTable[s * 2] + " " + mmuTable[s * 2 + 1]);
                            
                        } else if (mmuTable[s * 2] == currentProcess && mmuTable[s * 2 + 1] == addressForInt2 / memoryPageSize) {
                            console.log("2mmu table seg with int " + mmuTable[s * 2] + " " + mmuTable[s * 2 + 1]);
                            console.log("removing page");
                             mmuTable[s * 2] = getProcessDetails(currentProcessIndex, TABLE1_INTRET_PROCESS_NUM);
                            mmuTable[s * 2 + 1] = getProcessDetails(currentProcessIndex,  TABLE1_INTMEMPAGE2);
                            console.log("2mmu table seg with int " + mmuTable[s * 2] + " " + mmuTable[s * 2 + 1]);
                            
                        }
                    }

                    //restore process num
                    currentProcess = getProcessDetails(currentProcessIndex, TABLE1_INTRET_PROCESS_NUM);
                    changeProcessDetails(currentProcessIndex, TABLE1_PROCESS_NUM, currentProcess);

                    //switch to new values
                    logicalAddress = getProcessDetails(currentProcess, TABLE2_CODE);
                    // we're not in Cansas anymore
                    changeProcessDetails(currentProcessIndex, TABLE1_INTRET_PROCESS_NUM, 0);
                    intHandlers[getProcessDetails(currentProcessIndex, TABLE1_INTNUM) * intHandlerEntrySize] = 1; // sleep
                    changeProcessDetails(currentProcessIndex, TABLE1_INTNUM, 0);

                    if (debugLevel > 0) console.log("logical address " + logicalAddress);
                    break;
                case JUMPBACK:
                    logicalAddress -= (instruction[1] * 256 + instruction[2]) * bytesPerInstruction;
                    increaseAddress = false;
                    break;
                case JUMPPLUS:
                    logicalAddress += (instruction[1] * 256 + instruction[2]) * bytesPerInstruction;
                    increaseAddress = false;
                    break;
                case ADD:
                    value = instruction[3] * 256 + instruction[4];
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        changeRegister(j, getRegister(j) + value);
                    }
                    break;
                 case DEC:
                    value = instruction[3] * 256 + instruction[4];
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        changeRegister(j, getRegister(j) - value);
                    }
                    break;
                case MUL:
                    value = instruction[3] * 256 + instruction[4];
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        changeRegister(j, getRegister(j) * value);
                    }
                    break;
                case SET:
                    value = instruction[3] * 256 + instruction[4];
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        changeRegister(j, value);
                    }
                    break;
                case LOADFROMRAM8:
                    address = getRegister(instruction[3]);
                    value = memory[mmu(address, currentProcess)];
                    console.log("loading from ram " + value);
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        changeRegister(j, value);
                    }
                    break;
                    case LOADFROMRAM16:
                    address = getRegister(instruction[3]);
                    value = memory[mmu(address, currentProcess)]*256+memory[mmu(address+1, currentProcess)];
                    console.log("loading from ram " + value);
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        changeRegister(j, value);
                    }
                    break;
                case SAVETORAM8:
                    address = getRegister(instruction[3]);
                    for (j = instruction[1]; j <= instruction[2]; j++) {
                        memory[mmu(address, currentProcess)] = getRegister(j) % 256;
                        console.log("saving to ram value " + getRegister(j) % 256+ " address "+address+" "+mmu(address, currentProcess));
                        address++;
                    }
                    break;
                case CMPTRUE:
                    value1 = getRegister(instruction[1]);
                    value2 = instruction[2] * 256 + instruction[3];
                    console.log("comaping value " + value1 + " to value " + value2);
                    if (value1 != value2) {
                        logicalAddress += bytesPerInstruction;
                    }
                    break;
                case OUTPORT:
                    if (instruction[1] == 1) { // terminal screen
                        value = getRegister(instruction[2]);
                        if (value == 10) { // new line character
                            document.getElementById('terminal').innerHTML = document.getElementById('terminal').innerHTML + "<br>";
                        } else {
                            document.getElementById('terminal').innerHTML = document.getElementById('terminal').innerHTML + String.fromCharCode(value);
                        }
                    } else if (instruction[1] == 2) { // disk
                        value = getRegister(instruction[2]);
                        diskReadAddress = value;
                        console.log("reading disk address " + diskReadAddress);
                    }
                    break;
                case REGINPORT:
                    if (portInHandlers[instruction[1] * portInHandlerSize] == 0) {
                        portInHandlers[instruction[1] * portInHandlerSize] = currentProcess;
                        portInHandlers[instruction[1] * portInHandlerSize + 1] = (logicalAddress + bytesPerInstruction) / 256;
                        portInHandlers[instruction[1] * portInHandlerSize + 2] = (logicalAddress + bytesPerInstruction) % 256;
                        changeProcessDetails(currentProcess, TABLE1_ACTIVE, 1); // sleepy, sleepy
                        activeProcesses--;
                        if (debugLevel > 0) console.log("active processes " + activeProcesses);
                    }
                    break;
                case INPORT:
                    if (instruction[1] == 1) { //keyboard
                        code = 0;
                        if (keyboardInput.length > 0) {
                            code = keyboardInput.charCodeAt(keyboardInput.length - 1);
                            keyboardInput = keyboardInput.substring(0, keyboardInput - 1);
                            console.log(code + " " + keyboardInput);
                        }
                        for (j = instruction[2]; j <= instruction[3]; j++) {
                            changeRegister(j, code);
                        }
                    } else if (instruction[1] == 2) { // disk
                        code = disk[diskReadAddress];
                        console.log("byte from disk " + code);
                        diskRead++;
                        for (j = instruction[2]; j <= instruction[3]; j++) {
                            changeRegister(j, code);
                        }
                    }
                    break;
                case INPORTRET:
                    changeProcessDetails(currentProcess, TABLE1_ACTIVE, 1); // sleepy, sleepy
                    activeProcesses--;
                    if (debugLevel > 0) console.log("active processes " + activeProcesses);
                    break;
                    default:
                    console.log("wrong instrcution");
                    verywrong = true;
                    return;
            }
            if (increaseAddress) {
                logicalAddress += bytesPerInstruction;
            }
            instructions++;
            showInfo();
            dumpProcessInfo(currentProcessIndex);
            if (getProcessDetails(currentProcess, TABLE1_ACTIVE) == 1) break; // if process is sleepy go into next task
        }

        console.log("changing logicalAddres to currentProcess " + currentProcess + " " + TABLE2_CODE + " " + logicalAddress);
        changeProcessDetails(currentProcess, TABLE2_CODE, logicalAddress);
        dumpProcessInfo(currentProcessIndex);
    }

    bootloader();

    while (true) {
        execute();
          //if (instructions > 1000 || verywrong) break;
          if (verywrong) break;
        if (activeProcesses == 0) {
            console.log("sleeping");
            // todo: flushing all int support code
            break;
        }
    }

    function keyUpFunction(event) {
        keyboardInput = keyboardInput + String.fromCharCode(event.which);
        //FIXME: masked-unmasked
        console.log(keyboardInput);
        changeProcessDetails(portInHandlers[1 * portInHandlerSize], TABLE1_ACTIVE, 2); //active
        changeProcessDetails(portInHandlers[1 * portInHandlerSize], TABLE2_CODE,
            portInHandlers[1 * portInHandlerSize + 1] * 256 + portInHandlers[1 * portInHandlerSize + 2]);
        activeProcesses++;
        while (true) {
            execute();
            if (activeProcesses == 0) {
                // todo: flushing all int support code
                console.log("sleeping");
                break;
            }
        }
    }

    window.addEventListener('keyup', keyUpFunction.bind(this), false);
</script>

</html>
