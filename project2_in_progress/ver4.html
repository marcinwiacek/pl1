<!DOCTYPE html>
<html>

<head>
    <title>PL1 240218</title>
</head>

<body>
    <div id=info></div>
    <p>
    <div id=terminal></div>
</body>

<script>
    function dt(d) {
        return d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds() + ":" + d.getMilliseconds() + "    ";
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    const LOADFROMRAM8 = 11; //load register from memory, start, stop, address
    const JUMPPLUS = 23;

    const RAMMemory = new Uint8Array(1024);
    RAMreadBusy = false;
    RAMreadInput = 0;
    RAMreadInputDataReady = false;
    RAMreadOutput = 0;

    RAMread2Busy = false;
    RAMread2Input = 0;
    RAMread2InputDataReady = false;
    RAMread2Output = 0;

    RAMsaveBusy = false;
    RAMsaveAddressInput = 0;
    RAMsaveValueInput = 0;
    RAMsaveInputDataReady = false;
    async function RAM() {
        while (true) {
            await sleep(1);
            if (RAMreadInputDataReady) {
                RAMreadBusy = true;
                const d = new Date();
                await sleep(10);
                const d2 = new Date();
                RAMreadOutput = RAMMemory[RAMreadInput];
                console.log(dt(d) + dt(d2) + "processing RAM read " + RAMreadInput+" "+RAMreadOutput);
                RAMreadBusy = false;
                RAMreadInputDataReady = false;
            }
            if (RAMread2InputDataReady) {
                RAMread2Busy = true;
                const d = new Date();
                await sleep(10);
                const d2 = new Date();
                RAMread2Output = RAMMemory[RAMread2Input];
                console.log(dt(d) + dt(d2) + "processing RAM read2 " + RAMread2Input+" "+RAMread2Output);
                RAMread2Busy = false;
                RAMread2InputDataReady = false;
            }
            if (RAMsaveInputDataReady) {
                RAMsaveBusy = true;
                const d = new Date();
                await sleep(10);
                const d2 = new Date();
                console.log(dt(d) + dt(d2) + "processing RAM save " + RAMsaveAddressInput+" "+RAMsaveValueInput);
                RAMMemory[RAMsaveAddressInput]=RAMsaveValueInput;
                RAMsaveBusy = false;
                RAMsaveInputDataReady = false;
            }
        }
    }

    maxcycles = 20;
    counter = 0;
    processnr = 0;
    const thread = new Uint8Array(5);
    const threadAddress = new Uint8Array(5);
    const threadRegisterAddress = new Uint8Array(5);
    //instruction fetching
    async function stage1() {
        while (true) {
            await sleep(1);
            if (thread[processnr] == 0) {
                thread[processnr] = 1;
                const d = new Date();
                tempRAM = new Uint8Array(4);
                for (i = 0; i < 2; i++) {
                    RAMreadInput = threadAddress[processnr] + i;
                    RAMreadInputDataReady = true;
                    while (RAMreadInputDataReady) {
                        await sleep(1);
                    }
                    tempRAM[i] = RAMreadOutput;
                }
                if (stage2inputx[0] == JUMPPLUS) {
                    threadAddress[processnr]+=tempRAM[1]*4;
		    //jump can be fast
		} else {
                    for (i = 2; i < 4; i++) {
                        RAMreadInput = threadAddress[processnr] + i;
                        RAMreadInputDataReady = true;
                        while (RAMreadInputDataReady) {
                            await sleep(1);
                        }
                        tempRAM[i] = RAMreadOutput;
                    }
                    threadAddress[processnr]+=4;
                    while (stage2busy) {
                        await sleep(1);
                    }
                    const d2 = new Date();
                    console.log(dt(d) + dt(d2) + "processing 1 input " + processnr + " " + counter);
                    stage2input = processnr;
                    stage2input2 = counter;
                    for (i = 0; i < 4; i++) {
                        stage2inputx[i] = tempRAM[i];
                    }
                    counter++;
                    processnr++;
                    if (processnr == 2) processnr = 0;
                    stage2inputdataready = true;
                }
            }
            if (counter == maxcycles) break;
        }
    }

    // instruction decoding
    // with majority instructions we can initiate starting stage 1
    // and go into 3 or later
    stage2busy = false;
    stage2input = 0;
    stage2inputx = new Uint8Array(4);
    stage2input2 = 0;
    stage2inputdataready = false;
    async function stage2() {
        while (true) {
            await sleep(1);
            if (stage2inputdataready) {
                stage2busy = true;
                const d = new Date();
                await sleep(10);
                tempALU = false;
		tempRAMRead = false;
		tempRAMReadAddress = 0;
		tempSaveRegister = false;
		tempSaveRegisterAddress = 0;
		switch (stage2inputx[0]) {
                    case LOADFROMRAM8:
			tempRAMRead = true;
			tempSaveRegister = true;
	    		tempRAMReadAddress = stage2inputx[1];
			tempSaveRegisterAddress= stage2inputx[2];
			console.log("LOADFROMRAM8 from "+tempRAMReadAddress+" to "+tempSaveRegisterAddress);
			break;
		    default:
			break;
                }
            	const d2 = new Date();
                console.log(dt(d) + dt(d2) + "processing 2 input " + stage2input + " " + stage2input2);
                thread[stage2input] = 0;
		if (tempRAMRead) {
            		while (stage3busy) {
                	    await sleep(1);
            		}
                	stage3input = stage2input;
                	stage3input2 = stage2input2;
			stage3inputAddress = tempRAMReadAddress;
		        stage3register = tempSaveRegister;
		        stage3registerAddress = tempSaveRegisterAddress;
                	stage3inputdataready = true;
		}
                stage2busy = false;
                stage2inputdataready = false;
            }
            if (counter == maxcycles) break;
        }
    }

    //RAM get
    stage3busy = false;
    stage3input = 0;
    stage3input2 = 0;
    stage3inputAddress = 0;
    stage3register = false;
    stage3registerAddress = 0;
    stage3inputdataready = false;
    async function stage3() {
        while (true) {
            await sleep(1);
            if (stage3inputdataready) {
                stage3busy = true;
                const d = new Date();
                await sleep(10);

                    RAMread2Input = stage3inputAddress;
                    RAMread2InputDataReady = true;
                    while (RAMread2InputDataReady) {
                        await sleep(1);
                    }
                    tempRAM = RAMread2Output;

                while (stage5busy) {
                    await sleep(1);
                }
                const d2 = new Date();
                console.log(dt(d) + dt(d2) + "processing 3 input " + stage3input + " " + stage3input2);
                stage5input = stage3input;
                stage5input2 = stage3input2;
		stage5Address = stage3registerAddress;
		stage5Value = tempRAM;
                stage5inputdataready = true;
                stage3busy = false;
                stage3inputdataready = false;
            }
            if (counter == maxcycles) break;
        }
    }

    //ALU
    stage4busy = false;
    stage4input = 0;
    stage4input2 = 0;
    stage4inputdataready = false;
    async function stage4() {
        while (true) {
            await sleep(1);
            if (stage4inputdataready) {
                stage4busy = true;
                const d = new Date();
                await sleep(10);
                while (stage5busy) {
                    await sleep(1);
                }
                const d2 = new Date();
                console.log(dt(d) + dt(d2) + "processing 4 input " + stage4input + " " + stage4input2);
                stage5input = stage4input;
                stage5input2 = stage4input2;
                stage5inputdataready = true;
                stage4busy = false;
                stage4inputdataready = false;
            }
            if (counter == maxcycles) break;
        }
    }

    //RAM save
    //we just initiate memory saving and go further
    stage5busy = false;
    stage5input = 0;
    stage5input2 = 0;
    stage5Address = 0;
    stage5Value = 0;
    stage5inputdataready = false;
    async function stage5() {
        while (true) {
            await sleep(1);
            if (stage5inputdataready) {
                stage5busy = true;
                const d = new Date();
                await sleep(10);
                const d2 = new Date();
                console.log(dt(d) + dt(d2) + "processing 5 input " + stage5input + " " + stage5input2);
                while (RAMsaveBusy) {
                    await sleep(1);
                }
	        RAMsaveAddressInput = stage5Address;
	        RAMsaveValueInput = stage5Value;
                RAMsaveInputDataReady = true;
                stage5busy = false;
                stage5inputdataready = false;
            }
            if (counter == maxcycles) break;
        }
    }

    threadAddress[0] = 11;
    threadRegisterAddress[0] = 0;
    threadAddress[1] = 111;
    threadRegisterAddress[1] = 100;

    RAMMemory[11] = LOADFROMRAM8;
    RAMMemory[12] = 49;
    RAMMemory[13] = 1;
    RAMMemory[15] = LOADFROMRAM8;
    RAMMemory[16] = 1;
    RAMMemory[17] = 2;
    RAMMemory[49] = 127;
    RAM();
    stage1();
    stage2();
    stage3();
    stage4();
    stage5();

    //cache organization:
    //cache divided into two parts
    //physical location, value
    //physical location, value
</script>

</html>